// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package ttnv2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Modulation int32

const (
	Modulation_LORA Modulation = 0
	Modulation_FSK  Modulation = 1
)

var Modulation_name = map[int32]string{
	0: "LORA",
	1: "FSK",
}

var Modulation_value = map[string]int32{
	"LORA": 0,
	"FSK":  1,
}

func (x Modulation) String() string {
	return proto.EnumName(Modulation_name, int32(x))
}

func (Modulation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type LocationMetadata_LocationSource int32

const (
	LocationMetadata_UNKNOWN        LocationMetadata_LocationSource = 0
	LocationMetadata_GPS            LocationMetadata_LocationSource = 1
	LocationMetadata_CONFIG         LocationMetadata_LocationSource = 2
	LocationMetadata_REGISTRY       LocationMetadata_LocationSource = 3
	LocationMetadata_IP_GEOLOCATION LocationMetadata_LocationSource = 4
)

var LocationMetadata_LocationSource_name = map[int32]string{
	0: "UNKNOWN",
	1: "GPS",
	2: "CONFIG",
	3: "REGISTRY",
	4: "IP_GEOLOCATION",
}

var LocationMetadata_LocationSource_value = map[string]int32{
	"UNKNOWN":        0,
	"GPS":            1,
	"CONFIG":         2,
	"REGISTRY":       3,
	"IP_GEOLOCATION": 4,
}

func (x LocationMetadata_LocationSource) String() string {
	return proto.EnumName(LocationMetadata_LocationSource_name, int32(x))
}

func (LocationMetadata_LocationSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11, 0}
}

type Announcement struct {
	ID             string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ServiceName    string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	ServiceVersion string `protobuf:"bytes,3,opt,name=service_version,json=serviceVersion,proto3" json:"service_version,omitempty"`
	NetAddress     string `protobuf:"bytes,11,opt,name=net_address,json=netAddress,proto3" json:"net_address,omitempty"`
	PublicKey      string `protobuf:"bytes,12,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	Certificate    string `protobuf:"bytes,13,opt,name=certificate,proto3" json:"certificate,omitempty"`
}

func (m *Announcement) Reset()         { *m = Announcement{} }
func (m *Announcement) String() string { return proto.CompactTextString(m) }
func (*Announcement) ProtoMessage()    {}
func (*Announcement) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *Announcement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Announcement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Announcement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Announcement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Announcement.Merge(m, src)
}
func (m *Announcement) XXX_Size() int {
	return m.Size()
}
func (m *Announcement) XXX_DiscardUnknown() {
	xxx_messageInfo_Announcement.DiscardUnknown(m)
}

var xxx_messageInfo_Announcement proto.InternalMessageInfo

func (m *Announcement) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Announcement) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *Announcement) GetServiceVersion() string {
	if m != nil {
		return m.ServiceVersion
	}
	return ""
}

func (m *Announcement) GetNetAddress() string {
	if m != nil {
		return m.NetAddress
	}
	return ""
}

func (m *Announcement) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *Announcement) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

type GetRequest struct {
	ID          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ServiceName string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *GetRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

type ConnectMessage struct {
	GatewayID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Key       string `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ConnectMessage) Reset()         { *m = ConnectMessage{} }
func (m *ConnectMessage) String() string { return proto.CompactTextString(m) }
func (*ConnectMessage) ProtoMessage()    {}
func (*ConnectMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *ConnectMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectMessage.Merge(m, src)
}
func (m *ConnectMessage) XXX_Size() int {
	return m.Size()
}
func (m *ConnectMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectMessage proto.InternalMessageInfo

func (m *ConnectMessage) GetGatewayID() string {
	if m != nil {
		return m.GatewayID
	}
	return ""
}

func (m *ConnectMessage) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type DisconnectMessage struct {
	GatewayID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Key       string `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *DisconnectMessage) Reset()         { *m = DisconnectMessage{} }
func (m *DisconnectMessage) String() string { return proto.CompactTextString(m) }
func (*DisconnectMessage) ProtoMessage()    {}
func (*DisconnectMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *DisconnectMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisconnectMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisconnectMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisconnectMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisconnectMessage.Merge(m, src)
}
func (m *DisconnectMessage) XXX_Size() int {
	return m.Size()
}
func (m *DisconnectMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DisconnectMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DisconnectMessage proto.InternalMessageInfo

func (m *DisconnectMessage) GetGatewayID() string {
	if m != nil {
		return m.GatewayID
	}
	return ""
}

func (m *DisconnectMessage) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type UplinkMessage struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// ProtocolMessage message = 2;
	ProtocolMetadata ProtocolRxMetadata `protobuf:"bytes,11,opt,name=protocol_metadata,json=protocolMetadata,proto3" json:"protocol_metadata"`
	GatewayMetadata  GatewayRxMetadata  `protobuf:"bytes,12,opt,name=gateway_metadata,json=gatewayMetadata,proto3" json:"gateway_metadata"`
	Trace            *Trace             `protobuf:"bytes,21,opt,name=trace,proto3" json:"trace,omitempty"`
}

func (m *UplinkMessage) Reset()         { *m = UplinkMessage{} }
func (m *UplinkMessage) String() string { return proto.CompactTextString(m) }
func (*UplinkMessage) ProtoMessage()    {}
func (*UplinkMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *UplinkMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UplinkMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UplinkMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UplinkMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UplinkMessage.Merge(m, src)
}
func (m *UplinkMessage) XXX_Size() int {
	return m.Size()
}
func (m *UplinkMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UplinkMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UplinkMessage proto.InternalMessageInfo

func (m *UplinkMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *UplinkMessage) GetProtocolMetadata() ProtocolRxMetadata {
	if m != nil {
		return m.ProtocolMetadata
	}
	return ProtocolRxMetadata{}
}

func (m *UplinkMessage) GetGatewayMetadata() GatewayRxMetadata {
	if m != nil {
		return m.GatewayMetadata
	}
	return GatewayRxMetadata{}
}

func (m *UplinkMessage) GetTrace() *Trace {
	if m != nil {
		return m.Trace
	}
	return nil
}

type DownlinkMessage struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// ProtocolMessage message = 2;
	ProtocolConfiguration ProtocolTxConfiguration `protobuf:"bytes,11,opt,name=protocol_configuration,json=protocolConfiguration,proto3" json:"protocol_configuration"`
	GatewayConfiguration  GatewayTxConfiguration  `protobuf:"bytes,12,opt,name=gateway_configuration,json=gatewayConfiguration,proto3" json:"gateway_configuration"`
	Trace                 *Trace                  `protobuf:"bytes,21,opt,name=trace,proto3" json:"trace,omitempty"`
}

func (m *DownlinkMessage) Reset()         { *m = DownlinkMessage{} }
func (m *DownlinkMessage) String() string { return proto.CompactTextString(m) }
func (*DownlinkMessage) ProtoMessage()    {}
func (*DownlinkMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *DownlinkMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownlinkMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownlinkMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownlinkMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownlinkMessage.Merge(m, src)
}
func (m *DownlinkMessage) XXX_Size() int {
	return m.Size()
}
func (m *DownlinkMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DownlinkMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DownlinkMessage proto.InternalMessageInfo

func (m *DownlinkMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *DownlinkMessage) GetProtocolConfiguration() ProtocolTxConfiguration {
	if m != nil {
		return m.ProtocolConfiguration
	}
	return ProtocolTxConfiguration{}
}

func (m *DownlinkMessage) GetGatewayConfiguration() GatewayTxConfiguration {
	if m != nil {
		return m.GatewayConfiguration
	}
	return GatewayTxConfiguration{}
}

func (m *DownlinkMessage) GetTrace() *Trace {
	if m != nil {
		return m.Trace
	}
	return nil
}

type Trace struct {
	ID          string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Time        int64             `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	ServiceID   string            `protobuf:"bytes,3,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	ServiceName string            `protobuf:"bytes,4,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	Event       string            `protobuf:"bytes,5,opt,name=event,proto3" json:"event,omitempty"`
	Metadata    map[string]string `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Parents     []*Trace          `protobuf:"bytes,11,rep,name=parents,proto3" json:"parents,omitempty"`
}

func (m *Trace) Reset()         { *m = Trace{} }
func (m *Trace) String() string { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()    {}
func (*Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *Trace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trace.Merge(m, src)
}
func (m *Trace) XXX_Size() int {
	return m.Size()
}
func (m *Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_Trace proto.InternalMessageInfo

func (m *Trace) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Trace) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Trace) GetServiceID() string {
	if m != nil {
		return m.ServiceID
	}
	return ""
}

func (m *Trace) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *Trace) GetEvent() string {
	if m != nil {
		return m.Event
	}
	return ""
}

func (m *Trace) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Trace) GetParents() []*Trace {
	if m != nil {
		return m.Parents
	}
	return nil
}

type ProtocolRxMetadata struct {
	// Types that are valid to be assigned to Protocol:
	//	*ProtocolRxMetadata_LoRaWAN
	Protocol isProtocolRxMetadata_Protocol `protobuf_oneof:"protocol"`
}

func (m *ProtocolRxMetadata) Reset()         { *m = ProtocolRxMetadata{} }
func (m *ProtocolRxMetadata) String() string { return proto.CompactTextString(m) }
func (*ProtocolRxMetadata) ProtoMessage()    {}
func (*ProtocolRxMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *ProtocolRxMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolRxMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolRxMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolRxMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolRxMetadata.Merge(m, src)
}
func (m *ProtocolRxMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolRxMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolRxMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolRxMetadata proto.InternalMessageInfo

type isProtocolRxMetadata_Protocol interface {
	isProtocolRxMetadata_Protocol()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProtocolRxMetadata_LoRaWAN struct {
	LoRaWAN *LoRaWANMetadata `protobuf:"bytes,1,opt,name=lorawan,proto3,oneof"`
}

func (*ProtocolRxMetadata_LoRaWAN) isProtocolRxMetadata_Protocol() {}

func (m *ProtocolRxMetadata) GetProtocol() isProtocolRxMetadata_Protocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *ProtocolRxMetadata) GetLoRaWAN() *LoRaWANMetadata {
	if x, ok := m.GetProtocol().(*ProtocolRxMetadata_LoRaWAN); ok {
		return x.LoRaWAN
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ProtocolRxMetadata) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ProtocolRxMetadata_OneofMarshaler, _ProtocolRxMetadata_OneofUnmarshaler, _ProtocolRxMetadata_OneofSizer, []interface{}{
		(*ProtocolRxMetadata_LoRaWAN)(nil),
	}
}

func _ProtocolRxMetadata_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ProtocolRxMetadata)
	// protocol
	switch x := m.Protocol.(type) {
	case *ProtocolRxMetadata_LoRaWAN:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoRaWAN); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ProtocolRxMetadata.Protocol has unexpected type %T", x)
	}
	return nil
}

func _ProtocolRxMetadata_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ProtocolRxMetadata)
	switch tag {
	case 1: // protocol.lorawan
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoRaWANMetadata)
		err := b.DecodeMessage(msg)
		m.Protocol = &ProtocolRxMetadata_LoRaWAN{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ProtocolRxMetadata_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ProtocolRxMetadata)
	// protocol
	switch x := m.Protocol.(type) {
	case *ProtocolRxMetadata_LoRaWAN:
		s := proto.Size(x.LoRaWAN)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ProtocolTxConfiguration struct {
	// Types that are valid to be assigned to Protocol:
	//	*ProtocolTxConfiguration_LoRaWAN
	Protocol isProtocolTxConfiguration_Protocol `protobuf_oneof:"protocol"`
}

func (m *ProtocolTxConfiguration) Reset()         { *m = ProtocolTxConfiguration{} }
func (m *ProtocolTxConfiguration) String() string { return proto.CompactTextString(m) }
func (*ProtocolTxConfiguration) ProtoMessage()    {}
func (*ProtocolTxConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *ProtocolTxConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolTxConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolTxConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolTxConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolTxConfiguration.Merge(m, src)
}
func (m *ProtocolTxConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolTxConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolTxConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolTxConfiguration proto.InternalMessageInfo

type isProtocolTxConfiguration_Protocol interface {
	isProtocolTxConfiguration_Protocol()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProtocolTxConfiguration_LoRaWAN struct {
	LoRaWAN *LoRaWANTxConfiguration `protobuf:"bytes,1,opt,name=lorawan,proto3,oneof"`
}

func (*ProtocolTxConfiguration_LoRaWAN) isProtocolTxConfiguration_Protocol() {}

func (m *ProtocolTxConfiguration) GetProtocol() isProtocolTxConfiguration_Protocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *ProtocolTxConfiguration) GetLoRaWAN() *LoRaWANTxConfiguration {
	if x, ok := m.GetProtocol().(*ProtocolTxConfiguration_LoRaWAN); ok {
		return x.LoRaWAN
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ProtocolTxConfiguration) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ProtocolTxConfiguration_OneofMarshaler, _ProtocolTxConfiguration_OneofUnmarshaler, _ProtocolTxConfiguration_OneofSizer, []interface{}{
		(*ProtocolTxConfiguration_LoRaWAN)(nil),
	}
}

func _ProtocolTxConfiguration_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ProtocolTxConfiguration)
	// protocol
	switch x := m.Protocol.(type) {
	case *ProtocolTxConfiguration_LoRaWAN:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoRaWAN); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ProtocolTxConfiguration.Protocol has unexpected type %T", x)
	}
	return nil
}

func _ProtocolTxConfiguration_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ProtocolTxConfiguration)
	switch tag {
	case 1: // protocol.lorawan
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoRaWANTxConfiguration)
		err := b.DecodeMessage(msg)
		m.Protocol = &ProtocolTxConfiguration_LoRaWAN{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ProtocolTxConfiguration_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ProtocolTxConfiguration)
	// protocol
	switch x := m.Protocol.(type) {
	case *ProtocolTxConfiguration_LoRaWAN:
		s := proto.Size(x.LoRaWAN)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type LoRaWANMetadata struct {
	Modulation    Modulation `protobuf:"varint,11,opt,name=modulation,proto3,enum=ttnv2.Modulation" json:"modulation,omitempty"`
	DataRate      string     `protobuf:"bytes,12,opt,name=data_rate,json=dataRate,proto3" json:"data_rate,omitempty"`
	BitRate       uint32     `protobuf:"varint,13,opt,name=bit_rate,json=bitRate,proto3" json:"bit_rate,omitempty"`
	CodingRate    string     `protobuf:"bytes,14,opt,name=coding_rate,json=codingRate,proto3" json:"coding_rate,omitempty"`
	FCnt          uint32     `protobuf:"varint,15,opt,name=f_cnt,json=fCnt,proto3" json:"f_cnt,omitempty"`
	FrequencyPlan uint32     `protobuf:"varint,16,opt,name=frequency_plan,json=frequencyPlan,proto3" json:"frequency_plan,omitempty"`
}

func (m *LoRaWANMetadata) Reset()         { *m = LoRaWANMetadata{} }
func (m *LoRaWANMetadata) String() string { return proto.CompactTextString(m) }
func (*LoRaWANMetadata) ProtoMessage()    {}
func (*LoRaWANMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *LoRaWANMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoRaWANMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoRaWANMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoRaWANMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoRaWANMetadata.Merge(m, src)
}
func (m *LoRaWANMetadata) XXX_Size() int {
	return m.Size()
}
func (m *LoRaWANMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_LoRaWANMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_LoRaWANMetadata proto.InternalMessageInfo

func (m *LoRaWANMetadata) GetModulation() Modulation {
	if m != nil {
		return m.Modulation
	}
	return Modulation_LORA
}

func (m *LoRaWANMetadata) GetDataRate() string {
	if m != nil {
		return m.DataRate
	}
	return ""
}

func (m *LoRaWANMetadata) GetBitRate() uint32 {
	if m != nil {
		return m.BitRate
	}
	return 0
}

func (m *LoRaWANMetadata) GetCodingRate() string {
	if m != nil {
		return m.CodingRate
	}
	return ""
}

func (m *LoRaWANMetadata) GetFCnt() uint32 {
	if m != nil {
		return m.FCnt
	}
	return 0
}

func (m *LoRaWANMetadata) GetFrequencyPlan() uint32 {
	if m != nil {
		return m.FrequencyPlan
	}
	return 0
}

type LoRaWANTxConfiguration struct {
	Modulation Modulation `protobuf:"varint,11,opt,name=modulation,proto3,enum=ttnv2.Modulation" json:"modulation,omitempty"`
	DataRate   string     `protobuf:"bytes,12,opt,name=data_rate,json=dataRate,proto3" json:"data_rate,omitempty"`
	BitRate    uint32     `protobuf:"varint,13,opt,name=bit_rate,json=bitRate,proto3" json:"bit_rate,omitempty"`
	CodingRate string     `protobuf:"bytes,14,opt,name=coding_rate,json=codingRate,proto3" json:"coding_rate,omitempty"`
	FCnt       uint32     `protobuf:"varint,15,opt,name=f_cnt,json=fCnt,proto3" json:"f_cnt,omitempty"`
}

func (m *LoRaWANTxConfiguration) Reset()         { *m = LoRaWANTxConfiguration{} }
func (m *LoRaWANTxConfiguration) String() string { return proto.CompactTextString(m) }
func (*LoRaWANTxConfiguration) ProtoMessage()    {}
func (*LoRaWANTxConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *LoRaWANTxConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoRaWANTxConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoRaWANTxConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoRaWANTxConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoRaWANTxConfiguration.Merge(m, src)
}
func (m *LoRaWANTxConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *LoRaWANTxConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_LoRaWANTxConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_LoRaWANTxConfiguration proto.InternalMessageInfo

func (m *LoRaWANTxConfiguration) GetModulation() Modulation {
	if m != nil {
		return m.Modulation
	}
	return Modulation_LORA
}

func (m *LoRaWANTxConfiguration) GetDataRate() string {
	if m != nil {
		return m.DataRate
	}
	return ""
}

func (m *LoRaWANTxConfiguration) GetBitRate() uint32 {
	if m != nil {
		return m.BitRate
	}
	return 0
}

func (m *LoRaWANTxConfiguration) GetCodingRate() string {
	if m != nil {
		return m.CodingRate
	}
	return ""
}

func (m *LoRaWANTxConfiguration) GetFCnt() uint32 {
	if m != nil {
		return m.FCnt
	}
	return 0
}

type LocationMetadata struct {
	Time      int64                           `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Latitude  float32                         `protobuf:"fixed32,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude float32                         `protobuf:"fixed32,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Altitude  int32                           `protobuf:"varint,4,opt,name=altitude,proto3" json:"altitude,omitempty"`
	Accuracy  int32                           `protobuf:"varint,5,opt,name=accuracy,proto3" json:"accuracy,omitempty"`
	Source    LocationMetadata_LocationSource `protobuf:"varint,6,opt,name=source,proto3,enum=ttnv2.LocationMetadata_LocationSource" json:"source,omitempty"`
}

func (m *LocationMetadata) Reset()         { *m = LocationMetadata{} }
func (m *LocationMetadata) String() string { return proto.CompactTextString(m) }
func (*LocationMetadata) ProtoMessage()    {}
func (*LocationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *LocationMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationMetadata.Merge(m, src)
}
func (m *LocationMetadata) XXX_Size() int {
	return m.Size()
}
func (m *LocationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_LocationMetadata proto.InternalMessageInfo

func (m *LocationMetadata) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *LocationMetadata) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *LocationMetadata) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *LocationMetadata) GetAltitude() int32 {
	if m != nil {
		return m.Altitude
	}
	return 0
}

func (m *LocationMetadata) GetAccuracy() int32 {
	if m != nil {
		return m.Accuracy
	}
	return 0
}

func (m *LocationMetadata) GetSource() LocationMetadata_LocationSource {
	if m != nil {
		return m.Source
	}
	return LocationMetadata_UNKNOWN
}

type GatewayRxMetadata struct {
	GatewayID      string                       `protobuf:"bytes,1,opt,name=gateway_id,json=gatewayId,proto3" json:"gateway_id,omitempty"`
	GatewayTrusted bool                         `protobuf:"varint,2,opt,name=gateway_trusted,json=gatewayTrusted,proto3" json:"gateway_trusted,omitempty"`
	Timestamp      uint32                       `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Time           int64                        `protobuf:"varint,12,opt,name=time,proto3" json:"time,omitempty"`
	EncryptedTime  []byte                       `protobuf:"bytes,13,opt,name=encrypted_time,json=encryptedTime,proto3" json:"encrypted_time,omitempty"`
	RfChain        uint32                       `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	Channel        uint32                       `protobuf:"varint,22,opt,name=channel,proto3" json:"channel,omitempty"`
	Antennas       []*GatewayRxMetadata_Antenna `protobuf:"bytes,30,rep,name=antennas,proto3" json:"antennas,omitempty"`
	Frequency      uint64                       `protobuf:"varint,31,opt,name=frequency,proto3" json:"frequency,omitempty"`
	RSSI           float32                      `protobuf:"fixed32,32,opt,name=rssi,proto3" json:"rssi,omitempty"`
	SNR            float32                      `protobuf:"fixed32,33,opt,name=snr,proto3" json:"snr,omitempty"`
	Location       *LocationMetadata            `protobuf:"bytes,41,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *GatewayRxMetadata) Reset()         { *m = GatewayRxMetadata{} }
func (m *GatewayRxMetadata) String() string { return proto.CompactTextString(m) }
func (*GatewayRxMetadata) ProtoMessage()    {}
func (*GatewayRxMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *GatewayRxMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayRxMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayRxMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayRxMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayRxMetadata.Merge(m, src)
}
func (m *GatewayRxMetadata) XXX_Size() int {
	return m.Size()
}
func (m *GatewayRxMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayRxMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayRxMetadata proto.InternalMessageInfo

func (m *GatewayRxMetadata) GetGatewayID() string {
	if m != nil {
		return m.GatewayID
	}
	return ""
}

func (m *GatewayRxMetadata) GetGatewayTrusted() bool {
	if m != nil {
		return m.GatewayTrusted
	}
	return false
}

func (m *GatewayRxMetadata) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GatewayRxMetadata) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *GatewayRxMetadata) GetEncryptedTime() []byte {
	if m != nil {
		return m.EncryptedTime
	}
	return nil
}

func (m *GatewayRxMetadata) GetRfChain() uint32 {
	if m != nil {
		return m.RfChain
	}
	return 0
}

func (m *GatewayRxMetadata) GetChannel() uint32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *GatewayRxMetadata) GetAntennas() []*GatewayRxMetadata_Antenna {
	if m != nil {
		return m.Antennas
	}
	return nil
}

func (m *GatewayRxMetadata) GetFrequency() uint64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *GatewayRxMetadata) GetRSSI() float32 {
	if m != nil {
		return m.RSSI
	}
	return 0
}

func (m *GatewayRxMetadata) GetSNR() float32 {
	if m != nil {
		return m.SNR
	}
	return 0
}

func (m *GatewayRxMetadata) GetLocation() *LocationMetadata {
	if m != nil {
		return m.Location
	}
	return nil
}

type GatewayRxMetadata_Antenna struct {
	Antenna               uint32  `protobuf:"varint,1,opt,name=antenna,proto3" json:"antenna,omitempty"`
	Channel               uint32  `protobuf:"varint,2,opt,name=channel,proto3" json:"channel,omitempty"`
	RSSI                  float32 `protobuf:"fixed32,3,opt,name=rssi,proto3" json:"rssi,omitempty"`
	ChannelRSSI           float32 `protobuf:"fixed32,5,opt,name=channel_rssi,json=channelRssi,proto3" json:"channel_rssi,omitempty"`
	RSSIStandardDeviation float32 `protobuf:"fixed32,6,opt,name=rssi_standard_deviation,json=rssiStandardDeviation,proto3" json:"rssi_standard_deviation,omitempty"`
	FrequencyOffset       int64   `protobuf:"varint,7,opt,name=frequency_offset,json=frequencyOffset,proto3" json:"frequency_offset,omitempty"`
	SNR                   float32 `protobuf:"fixed32,4,opt,name=snr,proto3" json:"snr,omitempty"`
	EncryptedTime         []byte  `protobuf:"bytes,10,opt,name=encrypted_time,json=encryptedTime,proto3" json:"encrypted_time,omitempty"`
	FineTime              int64   `protobuf:"varint,11,opt,name=fine_time,json=fineTime,proto3" json:"fine_time,omitempty"`
}

func (m *GatewayRxMetadata_Antenna) Reset()         { *m = GatewayRxMetadata_Antenna{} }
func (m *GatewayRxMetadata_Antenna) String() string { return proto.CompactTextString(m) }
func (*GatewayRxMetadata_Antenna) ProtoMessage()    {}
func (*GatewayRxMetadata_Antenna) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12, 0}
}
func (m *GatewayRxMetadata_Antenna) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayRxMetadata_Antenna) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayRxMetadata_Antenna.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayRxMetadata_Antenna) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayRxMetadata_Antenna.Merge(m, src)
}
func (m *GatewayRxMetadata_Antenna) XXX_Size() int {
	return m.Size()
}
func (m *GatewayRxMetadata_Antenna) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayRxMetadata_Antenna.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayRxMetadata_Antenna proto.InternalMessageInfo

func (m *GatewayRxMetadata_Antenna) GetAntenna() uint32 {
	if m != nil {
		return m.Antenna
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetChannel() uint32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetRSSI() float32 {
	if m != nil {
		return m.RSSI
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetChannelRSSI() float32 {
	if m != nil {
		return m.ChannelRSSI
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetRSSIStandardDeviation() float32 {
	if m != nil {
		return m.RSSIStandardDeviation
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetFrequencyOffset() int64 {
	if m != nil {
		return m.FrequencyOffset
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetSNR() float32 {
	if m != nil {
		return m.SNR
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetEncryptedTime() []byte {
	if m != nil {
		return m.EncryptedTime
	}
	return nil
}

func (m *GatewayRxMetadata_Antenna) GetFineTime() int64 {
	if m != nil {
		return m.FineTime
	}
	return 0
}

type GatewayTxConfiguration struct {
	Timestamp             uint32 `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RfChain               uint32 `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	Frequency             uint64 `protobuf:"varint,22,opt,name=frequency,proto3" json:"frequency,omitempty"`
	Power                 int32  `protobuf:"varint,23,opt,name=power,proto3" json:"power,omitempty"`
	PolarizationInversion bool   `protobuf:"varint,31,opt,name=polarization_inversion,json=polarizationInversion,proto3" json:"polarization_inversion,omitempty"`
	FrequencyDeviation    uint32 `protobuf:"varint,32,opt,name=frequency_deviation,json=frequencyDeviation,proto3" json:"frequency_deviation,omitempty"`
}

func (m *GatewayTxConfiguration) Reset()         { *m = GatewayTxConfiguration{} }
func (m *GatewayTxConfiguration) String() string { return proto.CompactTextString(m) }
func (*GatewayTxConfiguration) ProtoMessage()    {}
func (*GatewayTxConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *GatewayTxConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayTxConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayTxConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayTxConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayTxConfiguration.Merge(m, src)
}
func (m *GatewayTxConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *GatewayTxConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayTxConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayTxConfiguration proto.InternalMessageInfo

func (m *GatewayTxConfiguration) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GatewayTxConfiguration) GetRfChain() uint32 {
	if m != nil {
		return m.RfChain
	}
	return 0
}

func (m *GatewayTxConfiguration) GetFrequency() uint64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *GatewayTxConfiguration) GetPower() int32 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *GatewayTxConfiguration) GetPolarizationInversion() bool {
	if m != nil {
		return m.PolarizationInversion
	}
	return false
}

func (m *GatewayTxConfiguration) GetFrequencyDeviation() uint32 {
	if m != nil {
		return m.FrequencyDeviation
	}
	return 0
}

type StatusMessage struct {
	Timestamp      uint32                   `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Time           int64                    `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	GatewayTrusted bool                     `protobuf:"varint,3,opt,name=gateway_trusted,json=gatewayTrusted,proto3" json:"gateway_trusted,omitempty"`
	BootTime       int64                    `protobuf:"varint,4,opt,name=boot_time,json=bootTime,proto3" json:"boot_time,omitempty"`
	IP             []string                 `protobuf:"bytes,11,rep,name=ip,proto3" json:"ip,omitempty"`
	Platform       string                   `protobuf:"bytes,12,opt,name=platform,proto3" json:"platform,omitempty"`
	ContactEmail   string                   `protobuf:"bytes,13,opt,name=contact_email,json=contactEmail,proto3" json:"contact_email,omitempty"`
	Description    string                   `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	FrequencyPlan  string                   `protobuf:"bytes,15,opt,name=frequency_plan,json=frequencyPlan,proto3" json:"frequency_plan,omitempty"`
	Bridge         string                   `protobuf:"bytes,16,opt,name=bridge,proto3" json:"bridge,omitempty"`
	Router         string                   `protobuf:"bytes,17,opt,name=router,proto3" json:"router,omitempty"`
	FPGA           uint32                   `protobuf:"varint,18,opt,name=fpga,proto3" json:"fpga,omitempty"`
	DSP            uint32                   `protobuf:"varint,19,opt,name=dsp,proto3" json:"dsp,omitempty"`
	HAL            string                   `protobuf:"bytes,20,opt,name=hal,proto3" json:"hal,omitempty"`
	Location       *LocationMetadata        `protobuf:"bytes,21,opt,name=location,proto3" json:"location,omitempty"`
	RTT            uint32                   `protobuf:"varint,31,opt,name=rtt,proto3" json:"rtt,omitempty"`
	RxIn           uint32                   `protobuf:"varint,41,opt,name=rx_in,json=rxIn,proto3" json:"rx_in,omitempty"`
	RxOk           uint32                   `protobuf:"varint,42,opt,name=rx_ok,json=rxOk,proto3" json:"rx_ok,omitempty"`
	TxIn           uint32                   `protobuf:"varint,43,opt,name=tx_in,json=txIn,proto3" json:"tx_in,omitempty"`
	TxOk           uint32                   `protobuf:"varint,44,opt,name=tx_ok,json=txOk,proto3" json:"tx_ok,omitempty"`
	LmOk           uint32                   `protobuf:"varint,45,opt,name=lm_ok,json=lmOk,proto3" json:"lm_ok,omitempty"`
	LmSt           uint32                   `protobuf:"varint,46,opt,name=lm_st,json=lmSt,proto3" json:"lm_st,omitempty"`
	LmNw           uint32                   `protobuf:"varint,47,opt,name=lm_nw,json=lmNw,proto3" json:"lm_nw,omitempty"`
	LPPS           uint32                   `protobuf:"varint,48,opt,name=l_pps,json=lPps,proto3" json:"l_pps,omitempty"`
	OS             *StatusMessage_OSMetrics `protobuf:"bytes,51,opt,name=os,proto3" json:"os,omitempty"`
	Messages       []string                 `protobuf:"bytes,52,rep,name=messages,proto3" json:"messages,omitempty"`
}

func (m *StatusMessage) Reset()         { *m = StatusMessage{} }
func (m *StatusMessage) String() string { return proto.CompactTextString(m) }
func (*StatusMessage) ProtoMessage()    {}
func (*StatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *StatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusMessage.Merge(m, src)
}
func (m *StatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *StatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_StatusMessage proto.InternalMessageInfo

func (m *StatusMessage) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *StatusMessage) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *StatusMessage) GetGatewayTrusted() bool {
	if m != nil {
		return m.GatewayTrusted
	}
	return false
}

func (m *StatusMessage) GetBootTime() int64 {
	if m != nil {
		return m.BootTime
	}
	return 0
}

func (m *StatusMessage) GetIP() []string {
	if m != nil {
		return m.IP
	}
	return nil
}

func (m *StatusMessage) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *StatusMessage) GetContactEmail() string {
	if m != nil {
		return m.ContactEmail
	}
	return ""
}

func (m *StatusMessage) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *StatusMessage) GetFrequencyPlan() string {
	if m != nil {
		return m.FrequencyPlan
	}
	return ""
}

func (m *StatusMessage) GetBridge() string {
	if m != nil {
		return m.Bridge
	}
	return ""
}

func (m *StatusMessage) GetRouter() string {
	if m != nil {
		return m.Router
	}
	return ""
}

func (m *StatusMessage) GetFPGA() uint32 {
	if m != nil {
		return m.FPGA
	}
	return 0
}

func (m *StatusMessage) GetDSP() uint32 {
	if m != nil {
		return m.DSP
	}
	return 0
}

func (m *StatusMessage) GetHAL() string {
	if m != nil {
		return m.HAL
	}
	return ""
}

func (m *StatusMessage) GetLocation() *LocationMetadata {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *StatusMessage) GetRTT() uint32 {
	if m != nil {
		return m.RTT
	}
	return 0
}

func (m *StatusMessage) GetRxIn() uint32 {
	if m != nil {
		return m.RxIn
	}
	return 0
}

func (m *StatusMessage) GetRxOk() uint32 {
	if m != nil {
		return m.RxOk
	}
	return 0
}

func (m *StatusMessage) GetTxIn() uint32 {
	if m != nil {
		return m.TxIn
	}
	return 0
}

func (m *StatusMessage) GetTxOk() uint32 {
	if m != nil {
		return m.TxOk
	}
	return 0
}

func (m *StatusMessage) GetLmOk() uint32 {
	if m != nil {
		return m.LmOk
	}
	return 0
}

func (m *StatusMessage) GetLmSt() uint32 {
	if m != nil {
		return m.LmSt
	}
	return 0
}

func (m *StatusMessage) GetLmNw() uint32 {
	if m != nil {
		return m.LmNw
	}
	return 0
}

func (m *StatusMessage) GetLPPS() uint32 {
	if m != nil {
		return m.LPPS
	}
	return 0
}

func (m *StatusMessage) GetOS() *StatusMessage_OSMetrics {
	if m != nil {
		return m.OS
	}
	return nil
}

func (m *StatusMessage) GetMessages() []string {
	if m != nil {
		return m.Messages
	}
	return nil
}

type StatusMessage_OSMetrics struct {
	Load_1           float32 `protobuf:"fixed32,1,opt,name=load_1,json=load1,proto3" json:"load_1,omitempty"`
	Load_5           float32 `protobuf:"fixed32,2,opt,name=load_5,json=load5,proto3" json:"load_5,omitempty"`
	Load_15          float32 `protobuf:"fixed32,3,opt,name=load_15,json=load15,proto3" json:"load_15,omitempty"`
	CPUPercentage    float32 `protobuf:"fixed32,11,opt,name=cpu_percentage,json=cpuPercentage,proto3" json:"cpu_percentage,omitempty"`
	MemoryPercentage float32 `protobuf:"fixed32,21,opt,name=memory_percentage,json=memoryPercentage,proto3" json:"memory_percentage,omitempty"`
	Temperature      float32 `protobuf:"fixed32,31,opt,name=temperature,proto3" json:"temperature,omitempty"`
}

func (m *StatusMessage_OSMetrics) Reset()         { *m = StatusMessage_OSMetrics{} }
func (m *StatusMessage_OSMetrics) String() string { return proto.CompactTextString(m) }
func (*StatusMessage_OSMetrics) ProtoMessage()    {}
func (*StatusMessage_OSMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14, 0}
}
func (m *StatusMessage_OSMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusMessage_OSMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusMessage_OSMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusMessage_OSMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusMessage_OSMetrics.Merge(m, src)
}
func (m *StatusMessage_OSMetrics) XXX_Size() int {
	return m.Size()
}
func (m *StatusMessage_OSMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusMessage_OSMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_StatusMessage_OSMetrics proto.InternalMessageInfo

func (m *StatusMessage_OSMetrics) GetLoad_1() float32 {
	if m != nil {
		return m.Load_1
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetLoad_5() float32 {
	if m != nil {
		return m.Load_5
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetLoad_15() float32 {
	if m != nil {
		return m.Load_15
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetCPUPercentage() float32 {
	if m != nil {
		return m.CPUPercentage
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetMemoryPercentage() float32 {
	if m != nil {
		return m.MemoryPercentage
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetTemperature() float32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func init() {
	proto.RegisterEnum("ttnv2.Modulation", Modulation_name, Modulation_value)
	proto.RegisterEnum("ttnv2.LocationMetadata_LocationSource", LocationMetadata_LocationSource_name, LocationMetadata_LocationSource_value)
	proto.RegisterType((*Announcement)(nil), "ttnv2.Announcement")
	proto.RegisterType((*GetRequest)(nil), "ttnv2.GetRequest")
	proto.RegisterType((*ConnectMessage)(nil), "ttnv2.ConnectMessage")
	proto.RegisterType((*DisconnectMessage)(nil), "ttnv2.DisconnectMessage")
	proto.RegisterType((*UplinkMessage)(nil), "ttnv2.UplinkMessage")
	proto.RegisterType((*DownlinkMessage)(nil), "ttnv2.DownlinkMessage")
	proto.RegisterType((*Trace)(nil), "ttnv2.Trace")
	proto.RegisterMapType((map[string]string)(nil), "ttnv2.Trace.MetadataEntry")
	proto.RegisterType((*ProtocolRxMetadata)(nil), "ttnv2.ProtocolRxMetadata")
	proto.RegisterType((*ProtocolTxConfiguration)(nil), "ttnv2.ProtocolTxConfiguration")
	proto.RegisterType((*LoRaWANMetadata)(nil), "ttnv2.LoRaWANMetadata")
	proto.RegisterType((*LoRaWANTxConfiguration)(nil), "ttnv2.LoRaWANTxConfiguration")
	proto.RegisterType((*LocationMetadata)(nil), "ttnv2.LocationMetadata")
	proto.RegisterType((*GatewayRxMetadata)(nil), "ttnv2.GatewayRxMetadata")
	proto.RegisterType((*GatewayRxMetadata_Antenna)(nil), "ttnv2.GatewayRxMetadata.Antenna")
	proto.RegisterType((*GatewayTxConfiguration)(nil), "ttnv2.GatewayTxConfiguration")
	proto.RegisterType((*StatusMessage)(nil), "ttnv2.StatusMessage")
	proto.RegisterType((*StatusMessage_OSMetrics)(nil), "ttnv2.StatusMessage.OSMetrics")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 1847 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x6e, 0x23, 0xb9,
	0xd5, 0xb6, 0xee, 0xd2, 0xd1, 0xc5, 0x32, 0xbb, 0x6d, 0x97, 0xdd, 0x63, 0xcb, 0xa3, 0x1f, 0x33,
	0x7f, 0xcf, 0xcd, 0x8e, 0xdd, 0xf1, 0x60, 0x90, 0x04, 0x09, 0x7c, 0xe9, 0xf6, 0x08, 0xed, 0xb6,
	0x14, 0x4a, 0x9d, 0xc9, 0x65, 0x21, 0xd0, 0x55, 0x94, 0x5c, 0x70, 0x89, 0x55, 0xc3, 0x62, 0xd9,
	0xad, 0x3c, 0x40, 0xd6, 0x79, 0x92, 0x00, 0x59, 0x05, 0x79, 0x83, 0x59, 0xce, 0x22, 0x8b, 0x04,
	0x01, 0x8c, 0x44, 0x0d, 0x64, 0x95, 0xbc, 0x43, 0xc0, 0x4b, 0x95, 0x24, 0x5f, 0x92, 0x06, 0x66,
	0x93, 0x9d, 0xce, 0x77, 0xbe, 0x73, 0x48, 0x1e, 0x7e, 0x3c, 0x64, 0x09, 0x4a, 0x24, 0x70, 0xb7,
	0x03, 0xee, 0x0b, 0x1f, 0xe5, 0x84, 0x60, 0x57, 0x7b, 0xeb, 0x9f, 0x0d, 0x5d, 0x71, 0x11, 0x9d,
	0x6f, 0xdb, 0xfe, 0x68, 0x67, 0xe8, 0x0f, 0xfd, 0x1d, 0xe5, 0x3d, 0x8f, 0x06, 0xca, 0x52, 0x86,
	0xfa, 0xa5, 0xa3, 0x9a, 0x7f, 0x4a, 0x41, 0xe5, 0x80, 0x31, 0x3f, 0x62, 0x36, 0x1d, 0x51, 0x26,
	0xd0, 0x0a, 0xa4, 0x5d, 0xc7, 0x4a, 0x6d, 0xa5, 0x9e, 0x96, 0x0e, 0xf3, 0x93, 0x9b, 0x46, 0xba,
	0x75, 0x8c, 0xd3, 0xae, 0x83, 0xde, 0x87, 0x4a, 0x48, 0xf9, 0x95, 0x6b, 0xd3, 0x3e, 0x23, 0x23,
	0x6a, 0xa5, 0x25, 0x03, 0x97, 0x0d, 0x76, 0x46, 0x46, 0x14, 0xfd, 0x3f, 0x2c, 0xc6, 0x94, 0x2b,
	0xca, 0x43, 0xd7, 0x67, 0x56, 0x46, 0xb1, 0x6a, 0x06, 0xfe, 0x99, 0x46, 0x51, 0x03, 0xca, 0x8c,
	0x8a, 0x3e, 0x71, 0x1c, 0x4e, 0xc3, 0xd0, 0x2a, 0x2b, 0x12, 0x30, 0x2a, 0x0e, 0x34, 0x82, 0x36,
	0x00, 0x82, 0xe8, 0xdc, 0x73, 0xed, 0xfe, 0x25, 0x1d, 0x5b, 0x15, 0xe5, 0x2f, 0x69, 0xe4, 0x25,
	0x1d, 0xa3, 0x2d, 0x28, 0xdb, 0x94, 0x0b, 0x77, 0xe0, 0xda, 0x44, 0x50, 0xab, 0xaa, 0xa7, 0x32,
	0x03, 0x35, 0x4f, 0x00, 0x4e, 0xa8, 0xc0, 0xf4, 0xeb, 0x88, 0x86, 0xdf, 0x65, 0x4d, 0xcd, 0x03,
	0xa8, 0x1d, 0xf9, 0x8c, 0x51, 0x5b, 0xbc, 0xa2, 0x61, 0x48, 0x86, 0x14, 0x6d, 0xcc, 0x24, 0xab,
	0x4e, 0x6e, 0x1a, 0xa5, 0x13, 0x22, 0xe8, 0x35, 0x19, 0x9b, 0x9c, 0x75, 0xc8, 0xc8, 0x39, 0xeb,
	0x85, 0xcb, 0x9f, 0xcd, 0x63, 0x58, 0x3a, 0x76, 0x43, 0xfb, 0x3b, 0x66, 0xf9, 0x47, 0x0a, 0xaa,
	0xaf, 0x03, 0xcf, 0x65, 0x97, 0x71, 0x0a, 0x0b, 0x0a, 0x01, 0x19, 0x7b, 0x3e, 0xd1, 0x79, 0x2a,
	0x38, 0x36, 0xd1, 0x29, 0x2c, 0xa9, 0xdd, 0xb5, 0x7d, 0xaf, 0x3f, 0xa2, 0x82, 0x38, 0x44, 0x10,
	0x55, 0xe5, 0xf2, 0xde, 0xda, 0xb6, 0x92, 0xc9, 0x76, 0xc7, 0xf8, 0xf1, 0x9b, 0x57, 0x86, 0x70,
	0x98, 0xfd, 0xe6, 0xa6, 0xb1, 0x80, 0xeb, 0x71, 0x64, 0x8c, 0xa3, 0x16, 0xd4, 0x87, 0x7a, 0x72,
	0xd3, 0x64, 0x15, 0x95, 0xcc, 0x32, 0xc9, 0xcc, 0xdc, 0xef, 0xe4, 0x5a, 0x34, 0x71, 0x49, 0xaa,
	0x26, 0xe4, 0x04, 0x27, 0x36, 0xb5, 0x96, 0x55, 0x7c, 0xc5, 0xc4, 0xf7, 0x24, 0x86, 0xb5, 0xab,
	0xf9, 0x9b, 0x34, 0x2c, 0x1e, 0xfb, 0xd7, 0xec, 0xdd, 0x96, 0xfa, 0x2b, 0x58, 0x49, 0x96, 0x6a,
	0xfb, 0x6c, 0xe0, 0x0e, 0x23, 0x4e, 0x84, 0x94, 0x9e, 0x5e, 0xef, 0xe6, 0xad, 0xf5, 0xf6, 0xde,
	0x1c, 0xcd, 0xb2, 0xcc, 0x44, 0x97, 0xe3, 0x1c, 0x73, 0x4e, 0xf4, 0x73, 0x58, 0x8e, 0x57, 0x3e,
	0x9f, 0x5b, 0x2f, 0x7f, 0x63, 0x7e, 0xf9, 0xf7, 0xa7, 0x7e, 0x6c, 0x32, 0xcc, 0x67, 0x7e, 0x97,
	0x42, 0xfc, 0x21, 0x0d, 0x39, 0x05, 0x3c, 0xa8, 0x5f, 0x04, 0x59, 0xe1, 0x1a, 0xdd, 0x66, 0xb0,
	0xfa, 0x8d, 0x3e, 0x05, 0x88, 0x35, 0xed, 0x3a, 0x5a, 0x40, 0x5a, 0x60, 0x5d, 0x8d, 0xb6, 0x8e,
	0x71, 0xc9, 0x10, 0x5a, 0x77, 0x4f, 0x40, 0xf6, 0xee, 0xa9, 0x7e, 0x0c, 0x39, 0x7a, 0x45, 0x99,
	0xb0, 0x72, 0xca, 0xa7, 0x0d, 0xf4, 0x39, 0x14, 0x13, 0x31, 0xe4, 0xb7, 0x32, 0x4f, 0xcb, 0x7b,
	0xeb, 0xb3, 0x6b, 0xd8, 0x8e, 0xb7, 0xfc, 0x39, 0x13, 0x7c, 0x8c, 0x13, 0x2e, 0xfa, 0x50, 0xee,
	0x24, 0xa7, 0x4c, 0xc8, 0x63, 0x9f, 0xb9, 0xb3, 0xf4, 0xd8, 0xb9, 0xfe, 0x43, 0xa8, 0xce, 0xa5,
	0x88, 0x4f, 0x44, 0x2a, 0x39, 0x11, 0x72, 0x62, 0x57, 0xc4, 0x8b, 0xe2, 0x63, 0xab, 0x8d, 0x1f,
	0xa4, 0xbf, 0x48, 0x35, 0x09, 0xa0, 0xbb, 0xfa, 0x46, 0x3f, 0x81, 0x82, 0xe7, 0x73, 0x72, 0x4d,
	0x98, 0xca, 0x52, 0xde, 0x5b, 0x31, 0x43, 0x9f, 0xfa, 0x98, 0x7c, 0x75, 0x70, 0x96, 0x88, 0xb7,
	0x3c, 0xb9, 0x69, 0x14, 0x0c, 0xf8, 0xe5, 0x02, 0x8e, 0xa3, 0x0e, 0x01, 0x8a, 0xb1, 0x4e, 0x9a,
	0x23, 0x58, 0x7d, 0x40, 0x52, 0xe8, 0xc5, 0xed, 0x71, 0x36, 0xe6, 0xc7, 0xb9, 0xad, 0x93, 0x77,
	0x19, 0xee, 0x2f, 0x29, 0x58, 0xbc, 0x35, 0x4d, 0xb4, 0x0b, 0x30, 0xf2, 0x9d, 0xc8, 0x9b, 0xca,
	0xbd, 0xb6, 0xb7, 0x64, 0x86, 0x7a, 0x95, 0x38, 0xf0, 0x0c, 0x09, 0x3d, 0x81, 0x92, 0x0c, 0xed,
	0x73, 0xd9, 0x36, 0x75, 0x5b, 0x2d, 0x4a, 0x00, 0x13, 0x41, 0xd1, 0x1a, 0x14, 0xcf, 0x5d, 0xa1,
	0x7d, 0xb2, 0xa5, 0x56, 0x71, 0xe1, 0xdc, 0x15, 0xca, 0xd5, 0x80, 0xb2, 0xed, 0x3b, 0x2e, 0x1b,
	0x6a, 0x6f, 0x4d, 0x37, 0x6c, 0x0d, 0x29, 0xc2, 0x23, 0xc8, 0x0d, 0xfa, 0x36, 0x13, 0xd6, 0xa2,
	0x0a, 0xcc, 0x0e, 0x8e, 0x98, 0x40, 0x1f, 0x40, 0x6d, 0xc0, 0x65, 0x0b, 0x66, 0xf6, 0xb8, 0x1f,
	0x78, 0x84, 0x59, 0x75, 0xe5, 0xad, 0x26, 0x68, 0xc7, 0x23, 0xac, 0xf9, 0xc7, 0x14, 0xac, 0xdc,
	0x5f, 0x9a, 0xff, 0xf9, 0x25, 0x36, 0x7f, 0x97, 0x86, 0xfa, 0xa9, 0x6f, 0xab, 0xa1, 0x93, 0x8d,
	0x89, 0x8f, 0x65, 0x6a, 0xe6, 0x58, 0xae, 0x43, 0x51, 0x4e, 0x50, 0x44, 0x8e, 0xd6, 0x6b, 0x1a,
	0x27, 0x36, 0x7a, 0x0f, 0x4a, 0x9e, 0xcf, 0x86, 0xda, 0x99, 0x51, 0xce, 0x29, 0x20, 0x23, 0x89,
	0x67, 0x22, 0xe5, 0xf1, 0xcc, 0xe1, 0xc4, 0x56, 0x3e, 0xdb, 0x8e, 0x38, 0xb1, 0xc7, 0xea, 0x78,
	0x4a, 0x9f, 0xb1, 0xd1, 0x8f, 0x21, 0x1f, 0xfa, 0x11, 0xb7, 0xa9, 0x95, 0x57, 0x75, 0xfb, 0x30,
	0x51, 0xe1, 0xfc, 0x74, 0x13, 0xa0, 0xab, 0xd8, 0xd8, 0x44, 0x35, 0x7b, 0x50, 0x9b, 0xf7, 0xa0,
	0x32, 0x14, 0x5e, 0x9f, 0xbd, 0x3c, 0x6b, 0x7f, 0x75, 0x56, 0x5f, 0x40, 0x05, 0xc8, 0x9c, 0x74,
	0xba, 0xf5, 0x14, 0x02, 0xc8, 0x1f, 0xb5, 0xcf, 0x5e, 0xb4, 0x4e, 0xea, 0x69, 0x54, 0x81, 0x22,
	0x7e, 0x7e, 0xd2, 0xea, 0xf6, 0xf0, 0x2f, 0xea, 0x19, 0x84, 0xa0, 0xd6, 0xea, 0xf4, 0x4f, 0x9e,
	0xb7, 0x4f, 0xdb, 0x47, 0x07, 0xbd, 0x56, 0xfb, 0xac, 0x9e, 0x6d, 0xfe, 0x3e, 0x0f, 0x4b, 0x77,
	0xae, 0x0b, 0xd9, 0xb4, 0xe2, 0x46, 0xfb, 0xd0, 0xad, 0x58, 0x32, 0x84, 0x96, 0x23, 0xdf, 0x19,
	0x31, 0x5b, 0xf0, 0x28, 0x14, 0xd4, 0x51, 0x25, 0x2d, 0xe2, 0x9a, 0x81, 0x7b, 0x1a, 0x95, 0x85,
	0x95, 0xc5, 0x0f, 0x05, 0x19, 0x05, 0x4a, 0x3d, 0x55, 0x3c, 0x05, 0x92, 0x6d, 0xaa, 0xcc, 0x6c,
	0xd3, 0x07, 0x50, 0xa3, 0xcc, 0xe6, 0xe3, 0x40, 0x50, 0xa7, 0xaf, 0xbc, 0x55, 0x75, 0xdf, 0x54,
	0x13, 0xb4, 0x27, 0x69, 0x6b, 0x50, 0xe4, 0x83, 0xbe, 0x7d, 0x41, 0x5c, 0xa6, 0x3a, 0x78, 0x15,
	0x17, 0xf8, 0xe0, 0x48, 0x9a, 0xf2, 0xaa, 0xb2, 0x2f, 0x08, 0x63, 0xd4, 0xb3, 0x56, 0xb4, 0xc7,
	0x98, 0xe8, 0x47, 0x50, 0x24, 0x4c, 0x50, 0xc6, 0x48, 0x68, 0x6d, 0xaa, 0xde, 0xb7, 0xf5, 0xd0,
	0xfd, 0xb9, 0x7d, 0xa0, 0x89, 0x38, 0x89, 0x90, 0x6b, 0x49, 0x8e, 0x8d, 0xd5, 0xd8, 0x4a, 0x3d,
	0xcd, 0xe2, 0x29, 0x80, 0xde, 0x83, 0x2c, 0x0f, 0x43, 0xd7, 0xda, 0x92, 0xea, 0x39, 0x2c, 0x4e,
	0x6e, 0x1a, 0x59, 0xdc, 0xed, 0xb6, 0xb0, 0x42, 0xd1, 0x1a, 0x64, 0x42, 0xc6, 0xad, 0xf7, 0x95,
	0xb3, 0x30, 0xb9, 0x69, 0x64, 0xba, 0x67, 0x18, 0x4b, 0x0c, 0x3d, 0x83, 0xa2, 0x67, 0x76, 0xd9,
	0xfa, 0x48, 0x75, 0xab, 0xd5, 0x07, 0x74, 0x82, 0x13, 0xe2, 0xfa, 0x3f, 0xd3, 0x50, 0x30, 0x33,
	0x94, 0xeb, 0x35, 0x73, 0x54, 0xfb, 0x56, 0xc5, 0xb1, 0x39, 0x5b, 0x89, 0xf4, 0x7c, 0x25, 0xe2,
	0xd9, 0x66, 0xee, 0x9d, 0xed, 0x1e, 0x54, 0x0c, 0xb1, 0xaf, 0x58, 0x39, 0xc5, 0x5a, 0x9c, 0xdc,
	0x34, 0xca, 0x47, 0x1a, 0x57, 0xe4, 0xb2, 0x21, 0x61, 0x19, 0xf3, 0x53, 0x58, 0x95, 0xdc, 0x7e,
	0x28, 0x08, 0x73, 0x08, 0x77, 0xfa, 0x0e, 0xbd, 0x72, 0xf5, 0xaa, 0xf2, 0x2a, 0x7c, 0x6d, 0x72,
	0xd3, 0x58, 0x96, 0x71, 0x5d, 0xc3, 0x38, 0x8e, 0x09, 0x78, 0x59, 0x46, 0xde, 0x81, 0xd1, 0x47,
	0x50, 0x9f, 0x76, 0x2f, 0x7f, 0x30, 0x08, 0xa9, 0xb0, 0x0a, 0x4a, 0x2a, 0x8b, 0x09, 0xde, 0x56,
	0x70, 0x5c, 0xdf, 0xec, 0x3d, 0xf5, 0xbd, 0x2b, 0x28, 0xb8, 0x4f, 0x50, 0x4f, 0xa0, 0x34, 0x70,
	0x19, 0xd5, 0x8c, 0xb2, 0x1a, 0xa5, 0x28, 0x01, 0xe9, 0x6c, 0xfe, 0x2b, 0x05, 0x2b, 0xf7, 0xbf,
	0x31, 0xfe, 0x8b, 0xc2, 0xff, 0x83, 0x4c, 0xe7, 0xe4, 0xb4, 0x72, 0x5b, 0x4e, 0x8f, 0x21, 0x17,
	0xf8, 0xd7, 0x94, 0x5b, 0xab, 0xaa, 0xa9, 0x68, 0x03, 0xed, 0xc3, 0x4a, 0xe0, 0x7b, 0x84, 0xbb,
	0xbf, 0x56, 0x83, 0xf7, 0x5d, 0x16, 0x3f, 0xf3, 0x1b, 0xea, 0xf8, 0x2d, 0xcf, 0x7a, 0x5b, 0xb1,
	0x13, 0xed, 0xc0, 0xa3, 0x69, 0x21, 0xa7, 0xfb, 0xb2, 0xa5, 0x26, 0x84, 0x12, 0x57, 0x52, 0xf9,
	0xe6, 0xdf, 0x0b, 0x50, 0xed, 0x0a, 0x22, 0xa2, 0x30, 0x7e, 0xff, 0xcd, 0x2d, 0x33, 0xf5, 0xd0,
	0x41, 0x9e, 0x7d, 0x06, 0xdd, 0xd3, 0x23, 0x32, 0xf7, 0xf6, 0x88, 0x27, 0x50, 0x3a, 0xf7, 0x7d,
	0xa1, 0x2b, 0x9f, 0xd5, 0x95, 0x97, 0x80, 0xda, 0x16, 0xf9, 0xf0, 0x0a, 0xd4, 0x43, 0x25, 0x7e,
	0x78, 0x75, 0x70, 0xda, 0x0d, 0x64, 0xdf, 0x0d, 0x3c, 0x22, 0x06, 0x3e, 0x1f, 0xc5, 0x77, 0x4c,
	0x6c, 0xa3, 0xff, 0x83, 0xaa, 0xed, 0x33, 0x41, 0x6c, 0xd1, 0xa7, 0x23, 0xe2, 0x7a, 0xe6, 0xf3,
	0xa4, 0x62, 0xc0, 0xe7, 0x12, 0x93, 0x5f, 0x30, 0x0e, 0x0d, 0x6d, 0xee, 0x06, 0xaa, 0x16, 0xfa,
	0xb6, 0x99, 0x85, 0xee, 0xb9, 0x3c, 0x17, 0x15, 0x69, 0xfe, 0xf2, 0x44, 0x2b, 0x90, 0x3f, 0xe7,
	0xae, 0x33, 0xa4, 0xea, 0x6e, 0x2d, 0x61, 0x63, 0x49, 0x9c, 0xfb, 0x91, 0xa0, 0xdc, 0x5a, 0xd2,
	0xb8, 0xb6, 0xe4, 0xd1, 0x1b, 0x04, 0x43, 0x62, 0x21, 0x59, 0x44, 0x7d, 0xf4, 0x5e, 0x74, 0x4e,
	0x0e, 0xb0, 0x42, 0xa5, 0x90, 0x9d, 0x30, 0xb0, 0x1e, 0x29, 0xa7, 0x12, 0xf2, 0x71, 0xb7, 0x83,
	0x25, 0x26, 0x5d, 0x17, 0xc4, 0xb3, 0x1e, 0xab, 0xde, 0xac, 0x5c, 0x5f, 0x1e, 0x9c, 0x62, 0x89,
	0xcd, 0xf5, 0x90, 0xe5, 0x77, 0xec, 0x21, 0x32, 0x1f, 0x17, 0x42, 0x29, 0xc7, 0x0c, 0x85, 0x7b,
	0x3d, 0x2c, 0x31, 0x79, 0xd3, 0xf2, 0x37, 0x7d, 0x57, 0x37, 0xa4, 0x2a, 0xce, 0xf2, 0x37, 0x2d,
	0x66, 0x40, 0xff, 0xd2, 0xfa, 0x38, 0x06, 0xdb, 0x97, 0x12, 0x14, 0x8a, 0xf9, 0x89, 0x06, 0x85,
	0x61, 0x0a, 0xc5, 0xfc, 0x34, 0x06, 0x35, 0xd3, 0x1b, 0x49, 0xf0, 0x33, 0x0d, 0x7a, 0xa3, 0x04,
	0x0c, 0x85, 0xb5, 0x1d, 0x83, 0x5d, 0x61, 0x40, 0x76, 0x6d, 0xed, 0xc4, 0xe0, 0xd9, 0x35, 0xda,
	0x80, 0x9c, 0xd7, 0x0f, 0x82, 0xd0, 0xfa, 0xde, 0xb4, 0x6e, 0xa7, 0x9d, 0x4e, 0x17, 0x67, 0xbd,
	0x4e, 0x10, 0xa2, 0xcf, 0x21, 0xed, 0x87, 0xd6, 0xb3, 0xb9, 0x2f, 0x8e, 0x39, 0x05, 0x6f, 0xb7,
	0xbb, 0xaf, 0xa8, 0xe0, 0xae, 0x1d, 0x6a, 0x1d, 0xb5, 0xbb, 0x38, 0xed, 0x87, 0x52, 0x47, 0x23,
	0x4d, 0x08, 0xad, 0xef, 0x4b, 0x95, 0xe1, 0xc4, 0x5e, 0xff, 0x6b, 0x0a, 0x4a, 0x49, 0x14, 0x5a,
	0x86, 0xbc, 0xfc, 0xde, 0xe9, 0xef, 0x2a, 0xf9, 0xa7, 0x71, 0x4e, 0x5a, 0xbb, 0x09, 0xbc, 0x6f,
	0x1e, 0x15, 0x0a, 0xde, 0x47, 0xab, 0xf2, 0x09, 0x2a, 0xd9, 0xfb, 0xe6, 0x3d, 0xa1, 0x58, 0xbb,
	0xfb, 0xe8, 0x0b, 0xa8, 0xd9, 0x41, 0xd4, 0x0f, 0x28, 0xb7, 0x29, 0x13, 0x64, 0xa8, 0x9b, 0x4d,
	0xfa, 0x70, 0x69, 0x72, 0xd3, 0xa8, 0x1e, 0x75, 0x5e, 0x77, 0x12, 0x07, 0xae, 0xda, 0x41, 0x34,
	0x35, 0xd1, 0x27, 0xb0, 0x34, 0xa2, 0x23, 0x9f, 0x8f, 0x67, 0x83, 0x97, 0x55, 0xf2, 0xba, 0x76,
	0xcc, 0x90, 0xb7, 0xa0, 0x2c, 0xe8, 0x28, 0xa0, 0x9c, 0x88, 0x88, 0x53, 0xb5, 0xc9, 0x69, 0x3c,
	0x0b, 0x7d, 0xdc, 0x00, 0x98, 0x3e, 0xe0, 0x50, 0x11, 0xb2, 0xa7, 0x6d, 0x7c, 0xa0, 0x9f, 0x15,
	0x2f, 0xba, 0x2f, 0xeb, 0xa9, 0xc3, 0x97, 0xdf, 0x4c, 0x36, 0x53, 0xdf, 0x4e, 0x36, 0x53, 0x7f,
	0x9b, 0x6c, 0xa6, 0x7e, 0xfb, 0x76, 0x73, 0xe1, 0xdb, 0xb7, 0x9b, 0x0b, 0x7f, 0x7e, 0xbb, 0xb9,
	0xf0, 0xcb, 0xdd, 0x99, 0x7f, 0x38, 0x7a, 0x17, 0xb4, 0x77, 0xe1, 0xb2, 0x61, 0xd8, 0x62, 0x4e,
	0x14, 0x0a, 0xee, 0xd2, 0x70, 0x67, 0x34, 0x0e, 0x85, 0xfb, 0x75, 0x44, 0x77, 0x82, 0xcb, 0xe1,
	0x8e, 0xda, 0x8b, 0xf3, 0xbc, 0x7a, 0x48, 0x3f, 0xfb, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x55,
	0xc2, 0x27, 0xaf, 0x2f, 0x11, 0x00, 0x00,
}

func (m *Announcement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Announcement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.ServiceVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServiceVersion)))
		i += copy(dAtA[i:], m.ServiceVersion)
	}
	if len(m.NetAddress) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.NetAddress)))
		i += copy(dAtA[i:], m.NetAddress)
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if len(m.Certificate) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Certificate)))
		i += copy(dAtA[i:], m.Certificate)
	}
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	return i, nil
}

func (m *ConnectMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GatewayID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GatewayID)))
		i += copy(dAtA[i:], m.GatewayID)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *DisconnectMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisconnectMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GatewayID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GatewayID)))
		i += copy(dAtA[i:], m.GatewayID)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *UplinkMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.ProtocolMetadata.Size()))
	n1, err := m.ProtocolMetadata.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x62
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.GatewayMetadata.Size()))
	n2, err := m.GatewayMetadata.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Trace != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Trace.Size()))
		n3, err := m.Trace.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *DownlinkMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownlinkMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.ProtocolConfiguration.Size()))
	n4, err := m.ProtocolConfiguration.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x62
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.GatewayConfiguration.Size()))
	n5, err := m.GatewayConfiguration.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.Trace != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Trace.Size()))
		n6, err := m.Trace.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Time))
	}
	if len(m.ServiceID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServiceID)))
		i += copy(dAtA[i:], m.ServiceID)
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.Event) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Event)))
		i += copy(dAtA[i:], m.Event)
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x32
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Parents) > 0 {
		for _, msg := range m.Parents {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProtocolRxMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolRxMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Protocol != nil {
		nn7, err := m.Protocol.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	return i, nil
}

func (m *ProtocolRxMetadata_LoRaWAN) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoRaWAN != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LoRaWAN.Size()))
		n8, err := m.LoRaWAN.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ProtocolTxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolTxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Protocol != nil {
		nn9, err := m.Protocol.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	return i, nil
}

func (m *ProtocolTxConfiguration_LoRaWAN) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LoRaWAN != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LoRaWAN.Size()))
		n10, err := m.LoRaWAN.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *LoRaWANMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoRaWANMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Modulation != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Modulation))
	}
	if len(m.DataRate) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DataRate)))
		i += copy(dAtA[i:], m.DataRate)
	}
	if m.BitRate != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BitRate))
	}
	if len(m.CodingRate) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CodingRate)))
		i += copy(dAtA[i:], m.CodingRate)
	}
	if m.FCnt != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FCnt))
	}
	if m.FrequencyPlan != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FrequencyPlan))
	}
	return i, nil
}

func (m *LoRaWANTxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoRaWANTxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Modulation != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Modulation))
	}
	if len(m.DataRate) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DataRate)))
		i += copy(dAtA[i:], m.DataRate)
	}
	if m.BitRate != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BitRate))
	}
	if len(m.CodingRate) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CodingRate)))
		i += copy(dAtA[i:], m.CodingRate)
	}
	if m.FCnt != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FCnt))
	}
	return i, nil
}

func (m *LocationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Time))
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i += 4
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i += 4
	}
	if m.Altitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Altitude))
	}
	if m.Accuracy != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Accuracy))
	}
	if m.Source != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Source))
	}
	return i, nil
}

func (m *GatewayRxMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayRxMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GatewayID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GatewayID)))
		i += copy(dAtA[i:], m.GatewayID)
	}
	if m.GatewayTrusted {
		dAtA[i] = 0x10
		i++
		if m.GatewayTrusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Time))
	}
	if len(m.EncryptedTime) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EncryptedTime)))
		i += copy(dAtA[i:], m.EncryptedTime)
	}
	if m.RfChain != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RfChain))
	}
	if m.Channel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Channel))
	}
	if len(m.Antennas) > 0 {
		for _, msg := range m.Antennas {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Frequency != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Frequency))
	}
	if m.RSSI != 0 {
		dAtA[i] = 0x85
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RSSI))))
		i += 4
	}
	if m.SNR != 0 {
		dAtA[i] = 0x8d
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SNR))))
		i += 4
	}
	if m.Location != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Location.Size()))
		n11, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *GatewayRxMetadata_Antenna) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayRxMetadata_Antenna) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Antenna != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Antenna))
	}
	if m.Channel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Channel))
	}
	if m.RSSI != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RSSI))))
		i += 4
	}
	if m.SNR != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SNR))))
		i += 4
	}
	if m.ChannelRSSI != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChannelRSSI))))
		i += 4
	}
	if m.RSSIStandardDeviation != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RSSIStandardDeviation))))
		i += 4
	}
	if m.FrequencyOffset != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FrequencyOffset))
	}
	if len(m.EncryptedTime) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EncryptedTime)))
		i += copy(dAtA[i:], m.EncryptedTime)
	}
	if m.FineTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FineTime))
	}
	return i, nil
}

func (m *GatewayTxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayTxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Frequency))
	}
	if m.Power != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Power))
	}
	if m.PolarizationInversion {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.PolarizationInversion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FrequencyDeviation != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FrequencyDeviation))
	}
	return i, nil
}

func (m *StatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Time))
	}
	if m.GatewayTrusted {
		dAtA[i] = 0x18
		i++
		if m.GatewayTrusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BootTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BootTime))
	}
	if len(m.IP) > 0 {
		for _, s := range m.IP {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.ContactEmail) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ContactEmail)))
		i += copy(dAtA[i:], m.ContactEmail)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.FrequencyPlan) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FrequencyPlan)))
		i += copy(dAtA[i:], m.FrequencyPlan)
	}
	if len(m.Bridge) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Bridge)))
		i += copy(dAtA[i:], m.Bridge)
	}
	if len(m.Router) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Router)))
		i += copy(dAtA[i:], m.Router)
	}
	if m.FPGA != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FPGA))
	}
	if m.DSP != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DSP))
	}
	if len(m.HAL) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HAL)))
		i += copy(dAtA[i:], m.HAL)
	}
	if m.Location != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Location.Size()))
		n12, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.RTT != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RTT))
	}
	if m.RxIn != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TxOk))
	}
	if m.LmOk != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LmOk))
	}
	if m.LmSt != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LmSt))
	}
	if m.LmNw != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LmNw))
	}
	if m.LPPS != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LPPS))
	}
	if m.OS != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OS.Size()))
		n13, err := m.OS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x3
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *StatusMessage_OSMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusMessage_OSMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Load_1 != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_1))))
		i += 4
	}
	if m.Load_5 != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_5))))
		i += 4
	}
	if m.Load_15 != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_15))))
		i += 4
	}
	if m.CPUPercentage != 0 {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CPUPercentage))))
		i += 4
	}
	if m.MemoryPercentage != 0 {
		dAtA[i] = 0xad
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MemoryPercentage))))
		i += 4
	}
	if m.Temperature != 0 {
		dAtA[i] = 0xfd
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Temperature))))
		i += 4
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Announcement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServiceVersion)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.NetAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ConnectMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GatewayID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DisconnectMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GatewayID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *UplinkMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.ProtocolMetadata.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.GatewayMetadata.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DownlinkMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.ProtocolConfiguration.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.GatewayConfiguration.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Trace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovApi(uint64(m.Time))
	}
	l = len(m.ServiceID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Event)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Parents) > 0 {
		for _, e := range m.Parents {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ProtocolRxMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != nil {
		n += m.Protocol.Size()
	}
	return n
}

func (m *ProtocolRxMetadata_LoRaWAN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoRaWAN != nil {
		l = m.LoRaWAN.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ProtocolTxConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != nil {
		n += m.Protocol.Size()
	}
	return n
}

func (m *ProtocolTxConfiguration_LoRaWAN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoRaWAN != nil {
		l = m.LoRaWAN.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *LoRaWANMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Modulation != 0 {
		n += 1 + sovApi(uint64(m.Modulation))
	}
	l = len(m.DataRate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BitRate != 0 {
		n += 1 + sovApi(uint64(m.BitRate))
	}
	l = len(m.CodingRate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.FCnt != 0 {
		n += 1 + sovApi(uint64(m.FCnt))
	}
	if m.FrequencyPlan != 0 {
		n += 2 + sovApi(uint64(m.FrequencyPlan))
	}
	return n
}

func (m *LoRaWANTxConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Modulation != 0 {
		n += 1 + sovApi(uint64(m.Modulation))
	}
	l = len(m.DataRate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BitRate != 0 {
		n += 1 + sovApi(uint64(m.BitRate))
	}
	l = len(m.CodingRate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.FCnt != 0 {
		n += 1 + sovApi(uint64(m.FCnt))
	}
	return n
}

func (m *LocationMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovApi(uint64(m.Time))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Altitude != 0 {
		n += 1 + sovApi(uint64(m.Altitude))
	}
	if m.Accuracy != 0 {
		n += 1 + sovApi(uint64(m.Accuracy))
	}
	if m.Source != 0 {
		n += 1 + sovApi(uint64(m.Source))
	}
	return n
}

func (m *GatewayRxMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GatewayID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GatewayTrusted {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovApi(uint64(m.Time))
	}
	l = len(m.EncryptedTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RfChain != 0 {
		n += 2 + sovApi(uint64(m.RfChain))
	}
	if m.Channel != 0 {
		n += 2 + sovApi(uint64(m.Channel))
	}
	if len(m.Antennas) > 0 {
		for _, e := range m.Antennas {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.Frequency != 0 {
		n += 2 + sovApi(uint64(m.Frequency))
	}
	if m.RSSI != 0 {
		n += 6
	}
	if m.SNR != 0 {
		n += 6
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GatewayRxMetadata_Antenna) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Antenna != 0 {
		n += 1 + sovApi(uint64(m.Antenna))
	}
	if m.Channel != 0 {
		n += 1 + sovApi(uint64(m.Channel))
	}
	if m.RSSI != 0 {
		n += 5
	}
	if m.SNR != 0 {
		n += 5
	}
	if m.ChannelRSSI != 0 {
		n += 5
	}
	if m.RSSIStandardDeviation != 0 {
		n += 5
	}
	if m.FrequencyOffset != 0 {
		n += 1 + sovApi(uint64(m.FrequencyOffset))
	}
	l = len(m.EncryptedTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.FineTime != 0 {
		n += 1 + sovApi(uint64(m.FineTime))
	}
	return n
}

func (m *GatewayTxConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		n += 2 + sovApi(uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		n += 2 + sovApi(uint64(m.Frequency))
	}
	if m.Power != 0 {
		n += 2 + sovApi(uint64(m.Power))
	}
	if m.PolarizationInversion {
		n += 3
	}
	if m.FrequencyDeviation != 0 {
		n += 2 + sovApi(uint64(m.FrequencyDeviation))
	}
	return n
}

func (m *StatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovApi(uint64(m.Time))
	}
	if m.GatewayTrusted {
		n += 2
	}
	if m.BootTime != 0 {
		n += 1 + sovApi(uint64(m.BootTime))
	}
	if len(m.IP) > 0 {
		for _, s := range m.IP {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ContactEmail)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.FrequencyPlan)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Bridge)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Router)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.FPGA != 0 {
		n += 2 + sovApi(uint64(m.FPGA))
	}
	if m.DSP != 0 {
		n += 2 + sovApi(uint64(m.DSP))
	}
	l = len(m.HAL)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.RTT != 0 {
		n += 2 + sovApi(uint64(m.RTT))
	}
	if m.RxIn != 0 {
		n += 2 + sovApi(uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		n += 2 + sovApi(uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		n += 2 + sovApi(uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		n += 2 + sovApi(uint64(m.TxOk))
	}
	if m.LmOk != 0 {
		n += 2 + sovApi(uint64(m.LmOk))
	}
	if m.LmSt != 0 {
		n += 2 + sovApi(uint64(m.LmSt))
	}
	if m.LmNw != 0 {
		n += 2 + sovApi(uint64(m.LmNw))
	}
	if m.LPPS != 0 {
		n += 2 + sovApi(uint64(m.LPPS))
	}
	if m.OS != nil {
		l = m.OS.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *StatusMessage_OSMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Load_1 != 0 {
		n += 5
	}
	if m.Load_5 != 0 {
		n += 5
	}
	if m.Load_15 != 0 {
		n += 5
	}
	if m.CPUPercentage != 0 {
		n += 5
	}
	if m.MemoryPercentage != 0 {
		n += 6
	}
	if m.Temperature != 0 {
		n += 6
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Announcement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Announcement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Announcement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisconnectMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisconnectMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisconnectMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UplinkMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProtocolMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GatewayMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &Trace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownlinkMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownlinkMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownlinkMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProtocolConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GatewayConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &Trace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parents = append(m.Parents, &Trace{})
			if err := m.Parents[len(m.Parents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolRxMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolRxMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolRxMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoRaWAN", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoRaWANMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Protocol = &ProtocolRxMetadata_LoRaWAN{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolTxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolTxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolTxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoRaWAN", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoRaWANTxConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Protocol = &ProtocolTxConfiguration_LoRaWAN{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoRaWANMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoRaWANMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoRaWANMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modulation", wireType)
			}
			m.Modulation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modulation |= Modulation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitRate", wireType)
			}
			m.BitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BitRate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodingRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCnt", wireType)
			}
			m.FCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyPlan", wireType)
			}
			m.FrequencyPlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyPlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoRaWANTxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoRaWANTxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoRaWANTxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modulation", wireType)
			}
			m.Modulation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modulation |= Modulation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitRate", wireType)
			}
			m.BitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BitRate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodingRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCnt", wireType)
			}
			m.FCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			m.Altitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Altitude |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accuracy", wireType)
			}
			m.Accuracy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accuracy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= LocationMetadata_LocationSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayRxMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayRxMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayRxMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GatewayTrusted = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTime = append(m.EncryptedTime[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTime == nil {
				m.EncryptedTime = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Antennas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Antennas = append(m.Antennas, &GatewayRxMetadata_Antenna{})
			if err := m.Antennas[len(m.Antennas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSSI", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RSSI = float32(math.Float32frombits(v))
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNR", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SNR = float32(math.Float32frombits(v))
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &LocationMetadata{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayRxMetadata_Antenna) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Antenna: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Antenna: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Antenna", wireType)
			}
			m.Antenna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Antenna |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSSI", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RSSI = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNR", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SNR = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelRSSI", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChannelRSSI = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSSIStandardDeviation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RSSIStandardDeviation = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyOffset", wireType)
			}
			m.FrequencyOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTime = append(m.EncryptedTime[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTime == nil {
				m.EncryptedTime = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FineTime", wireType)
			}
			m.FineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FineTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayTxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayTxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayTxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolarizationInversion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolarizationInversion = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyDeviation", wireType)
			}
			m.FrequencyDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyDeviation |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GatewayTrusted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootTime", wireType)
			}
			m.BootTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BootTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = append(m.IP, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyPlan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrequencyPlan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Router = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FPGA", wireType)
			}
			m.FPGA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FPGA |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSP", wireType)
			}
			m.DSP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DSP |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HAL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HAL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &LocationMetadata{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTT", wireType)
			}
			m.RTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTT |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxIn", wireType)
			}
			m.RxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOk", wireType)
			}
			m.RxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxOk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			m.TxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOk", wireType)
			}
			m.TxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxOk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmOk", wireType)
			}
			m.LmOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmOk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmSt", wireType)
			}
			m.LmSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmSt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmNw", wireType)
			}
			m.LmNw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmNw |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LPPS", wireType)
			}
			m.LPPS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LPPS |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OS == nil {
				m.OS = &StatusMessage_OSMetrics{}
			}
			if err := m.OS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusMessage_OSMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_1 = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_5", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_5 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_15", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_15 = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CPUPercentage = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MemoryPercentage = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Temperature = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthApi
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)
